<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>风力发电基础</title>
    <url>/2020/07/10/windtoelec/</url>
    <content><![CDATA[<h2 id="风力发电基础"><a href="#风力发电基础" class="headerlink" title="风力发电基础"></a>风力发电基础</h2><blockquote>
<p><strong>风到底是怎么变成电的呢？</strong><br>最基本原理是利用风带动风车叶片进行转动，将风能转化为机械能，使用机械能带动风力发电机发电</p>
</blockquote>
<a id="more"></a>
<p>[TOC]</p>
<h3 id="风力发电基本原理"><a href="#风力发电基本原理" class="headerlink" title="风力发电基本原理"></a>风力发电基本原理</h3><p>风力发电机主要包含三部分</p>
<ul>
<li>风轮</li>
<li>机舱</li>
<li>塔杆</li>
</ul>
<p>大型与电网接驳的风力发电机的最常见的结构，是横轴式三叶片风轮，并安装在直立管状塔杆上。</p>
<p>　　比较简单的风力发电机是采用<strong>固定速度</strong>的。通常采用两个不同的速度。即在弱风下用低速和在强风下用高速。这些定速风电机的感应式异步发电机能够直接发产生电网频率的交流电。</p>
<p>　　比较新型的设计一般是<strong>可变速的</strong>(比如Vestas 公司的V52-850千瓦风电机转速为每分钟14转到每分钟31.4 转)。利用可变速操作，风轮的空气动力效率可以得到改善，从而提取更多的能量，而且在弱风情况下噪音更低。<sup><a href="#fn_1" id="reffn_1">1</a></sup></p>
<p><strong>所有风力发电机的功率输出是随着风力而变的。</strong></p>
<p>强风下最常见的两种限制功率输出的方法(从而限制风轮所承受压力)</p>
<ul>
<li><p><strong>失速调节</strong>：使用失速调节的风电机，超过额定风速的强风会导致通过叶片的气流产生扰流，令风轮失速。当风力过强时，叶片尾部制动装置会动作，令风轮刹车。</p>
</li>
<li><p><strong>斜角调节</strong>：使用斜角调节的风电机，每片叶片能够以纵向为轴而旋转，叶片角度随着风速不同而转变，从而改变风轮的空气动力性能。当风力过强时，叶片转动至迎气边缘面向来风，从而令风轮刹车<sup><a href="#fn_2" id="reffn_2">2</a></sup>。</p>
</li>
</ul>
<h3 id="风轮机理论"><a href="#风轮机理论" class="headerlink" title="风轮机理论"></a>风轮机理论</h3><p>风轮机是把风的动能变成机械能的重要部件，当风吹向桨叶时，桨叶上产生的气动力驱动风轮转动。其主要分为：</p>
<ul>
<li>水平轴风轮机</li>
<li>垂直轴风轮机</li>
<li>特殊风轮机</li>
</ul>
<h3 id="定浆距风力发电机组"><a href="#定浆距风力发电机组" class="headerlink" title="定浆距风力发电机组"></a>定浆距风力发电机组</h3><p><em>what</em>：风力机的功率调节完全依靠叶片的气动特性。<br><em>how</em>：桨叶与轮毂的连接是固定的，即当风速变化时，桨叶的迎风角度不能随之变化。风力机获得的功率随风速不停的变化<sup><a href="#fn_3" id="reffn_3">3</a></sup>。</p>
<p>　　风电机组一般工作在小于额定风速时风轮机的转换效率Cp的最佳区段。当风速超过额定风速时，为了确保发电机输出功率恒定，通过叶片失速来降低Cp，来维持功率恒定。定浆距发电系统的发电机正常工作滑差小于1%，允许的滑差范围一般小于5%，但是风速变化范围却很大。下图为风轮机的典型Cp~λ特性曲线。</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/betz.png" style="zoom:70%" ></div>

<blockquote>
<p>由上图可以看出风机功率系数是有极限的，也就是著名的betz极限。下面是其推导过程。</p>
</blockquote>
<h4 id="betz极限"><a href="#betz极限" class="headerlink" title="betz极限"></a>betz极限</h4><p>假设将通过风轮的空气从空气中分离出来当作孤立的事物来看待,那么就可以形成一个横截面为圆形的长的气流管。假定风轮是理想的，那么气流管中的空气质量和流量都相等。但由于气流管中的空气经叶轮后速度下降,且其质量不变，密度将减小，体积会变大，因此流管的横截面积将会发生膨胀<sup><a href="#fn_4" id="reffn_4">4</a></sup>。贝茨定律的极限是理论上最大的风能利用系数。</p>
<p><strong>理想风轮</strong>：能全部接受风能并且没有轮毂，叶片是无限多，对气流没有任何阻力。而空气流是连续的，不可压缩的，叶片扫掠面上的气流是均匀的，气流速度的方向不论在叶片前或流经叶片后都是垂直叶片扫掠面的(或称为是平行风轮轴线的)<sup><a href="#fn_5" id="reffn_5">5</a></sup>。</p>
<h5 id="假定条件"><a href="#假定条件" class="headerlink" title="假定条件"></a>假定条件</h5><p>普通气流理想化为平流，假定速度为$v_1$</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/windfirst.png" style="zoom:50%" ></div>

<p>在普通气流中加入理想风轮，由于速度会不突变，体积会变大，在横截面发生膨胀，因此通过理想风轮的末速度为$v_2$，通过风轮的瞬间速度为$v$，<strong>但是由于动能没有改变，那么在风通过理想风轮的瞬间是什么能量变成机械能了呢？</strong>实际上是压强发生了突然减小，使得风轮转动，因此设大气压强为$p$，通过风轮前的瞬间压强为$p_1$，通过风轮后的瞬间压强为$p_2$</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/usewindpower.png" style="zoom:40%" ></div>

<p>同时设风车面积为$A$，空气密度为$\rho$，</p>
<h5 id="推导方法一"><a href="#推导方法一" class="headerlink" title="推导方法一"></a>推导方法一</h5><p>叶片处单位时间内通过的风的质量<script type="math/tex">M = \rho \times A \times \frac{v_1 + v_2}{2}</script></p>
<p>由牛顿第二定律(牛顿：这还是我的管辖范围)风机的机械能等于初始动能减去最终动能，因此机械能为：<script type="math/tex">P = \frac{1}{2} \times M \times (v_1 ^2 - v_2 ^2)</script></p>
<p>将上式带入下式中得到<script type="math/tex">P = \frac{ \rho }{2} \times A \times (v_1 ^2 - v_2 ^2)\frac{v_1 + v_2}{2}</script></p>
<p>风能的基本计算公式为：<script type="math/tex">P_0 = \frac{ \rho }{2} \times A \times v_1 ^3</script></p>
<p>所以经过化简可知<script type="math/tex">\frac{P}{P_0} = \frac{1}{2} \times [1 - (\frac{v_2}{v_1})^2] \times (1 + \frac{v_2}{v_1})</script><br>此时可以得知为$\frac{v_2}{v_1} $的三次函数，通过求导求极限的方法得到$ \frac{1}{3} $和$-1$两个驻点，因为速度为正数所以当$ \frac{v_2}{v_1} = \frac{1}{3} $时，最大值为$ \frac{P}{P_0} = \frac{16}{27} \approx 59 $%</p>
<h5 id="推导方法二"><a href="#推导方法二" class="headerlink" title="推导方法二"></a>推导方法二</h5><p>此方法主要通过压强到能量的计算来推导：由伯努利方程可知：<script type="math/tex">p + \frac{1}{2}\rho v_1 ^2 = p_1 + \frac{1}{2}\rho v ^2</script></p>
<script type="math/tex; mode=display">p + \frac{1}{2}\rho v_2 ^2 = p_2 + \frac{1}{2}\rho v ^2</script><p>相减可得：</p>
<script type="math/tex; mode=display">p_1 - p_2 =  \frac{1}{2}\rho (v_1 ^2 - v_2 ^2)</script><p>伯努利方程本身为能量方程，因此计算动量变化率为：<script type="math/tex">A (p_1 - p_2) = \rho Q (v_1 - v_2) = \rho A v (v_1 - v_2)</script><br>所以$v = \frac{v_1 + v_2}{2}$</p>
<p>因此当风车不存在的时候，单位时间通过A的气流动能为：<script type="math/tex">A v_1 \times \frac{1}{2}\rho v_1 ^2 = \frac{ \rho }{2} \times A \times v_1 ^3</script></p>
<p>风车存在的时候：<script type="math/tex">A v (\frac{1}{2}\rho v_1 ^2 - \frac{1}{2}\rho v_2 ^2)</script></p>
<p>上下两式子做比得到：</p>
<script type="math/tex; mode=display">\frac{A v (\frac{1}{2}\rho v_1 ^2 - \frac{1}{2}\rho v_2 ^2)}{\frac{ \rho }{2} \times A \times v_1 ^3} = \frac{4v^2(v_1 - v)}{v_1 ^ 3 }</script><p>将$v = \frac{v_1 + v_2}{2}$带入可知$v = \frac{2}{3} v_1$时效率最高。也可以得到betz极限为<strong>59%</strong></p>
<h3 id="永磁同步发电机基本原理"><a href="#永磁同步发电机基本原理" class="headerlink" title="永磁同步发电机基本原理"></a>永磁同步发电机基本原理</h3><p>目前世界上的发电量几乎全部是由同步发电机发出，其即可以作为发电机运行，又可以作为电动机运行。功率因数可以调节，但是转速不可以调节。<br>基本原理<sup><a href="#fn_6" id="reffn_6">6</a></sup></p>
<h4 id="同步电机基础"><a href="#同步电机基础" class="headerlink" title="同步电机基础"></a>同步电机基础</h4><p>同步电机之所以叫同步电机，是因为其转速$n$和定子电流的频率$f_1$之间存在严格的确定的关系<script type="math/tex">n = n_0 = \frac{60 f_1}{p}</script><br>其中$n_0$是同步转速。而异步电机在稳定运行的时候其转速不等于同步转速。</p>
<p>出现区别的原因是由<strong>两者转子中的电流中的性质不同</strong>所导致的。异步电机稳态运行时，其转子转速为$n$，转子电流频率$f_2 = sf_1$，转速差为$s = \frac {n_0 - n}{n_0}$，如果转子的转速和定子的旋转磁场的转速是相同的，那么$s= 0$，则转子电流频率$f_2 = 0$，这意味着转子绕组内的电流是直流电流。</p>
<p>如果改变异步电机的转子结构，使它成为用直流电流励磁，且可以转动的电磁铁，这样的交流电机便是同步电机。</p>
<h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>其主要由定子和转子组成。</p>
<ul>
<li><p>定子：<br><em>what</em>：由导磁的定子铁心和导电的三相绕组以及固定铁心用的基座和端盖等部件组成。<br><em>how</em>：可以输入输出电功率，并且产生旋转磁场。</p>
</li>
<li><p>转子：<br><em>what</em>：一种是有明显磁极的凸极式，一个是在圆柱体上开一些槽，没有明显磁极的隐极式。主要由磁极，磁轭，励磁绕组，转子支架，轴以及集电环等部件组成。<br><em>how</em>：通过励磁电流以后的相邻磁极的极性呈N与S交替排列，励磁绕组两个出线端接在两个集电环上，通过与集电环相接触的静止电刷向外引出。</p>
</li>
</ul>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p><strong>根本基于电磁感应定律</strong></p>
<p><strong>空载特性</strong>：当同步发电机的直流电流励磁的转子由原动机拖动到同步转速$n_0$时，定子上静止开路的三相绕组(也称电枢绕组)，与旋转转子上的磁极在空隙中所建立旋转磁场相对运动，定子绕组磁链发生变化。</p>
<p>根据电磁感应定律，定子绕组内由此感应产生感应电动势$E_0$(称为励磁电动势)。改变励磁电流$I_f$的大小可相应的改变励磁电动势$E_0$的大小。此时同步电机作发电机运行而呈空载状态。在同步转速下，励磁电动势$E_0$与励磁电流$I_f$的关系即为同步电机作为发电机的空载特性。</p>
<p>那么是怎么发电的呢？实际上在空载运行的时候其端电压$U_0 = E_0$，在定子绕组上接上对称负载，同步电动机出于负载运行状态，此时原动机（比如本文中所提到的风轮机）向发电机输入机械功率，发电机从定子绕组输出电功率，经过机电能量转换，产生电能。</p>
<h3 id="风力发电建模"><a href="#风力发电建模" class="headerlink" title="风力发电建模"></a>风力发电建模</h3><blockquote>
<p><strong>风到底是怎么变成电的呢？</strong>下边这个模型可以窥探一二。</p>
</blockquote>
<h4 id="风速模型"><a href="#风速模型" class="headerlink" title="风速模型"></a>风速模型</h4><p>因为风具有随机性和间歇性的特点，因此风速模型一般采用四分量叠加法，即：$v = v_b + v_g + v_r + v_t $，为基本风，阵风，渐变风和随机风<sup><a href="#fn_7" id="reffn_7">7</a></sup>。</p>
<ul>
<li>基本风：常用的确定基本风速的概率分布为威布尔分布和瑞利分布，而基本风的分布本质上是正偏态分布，这时候使用威布尔分布模拟在实际测量中拟合效果好。同时在这个公式中可以看到，当k=1时为指数分布，k=2时为瑞利分布。<script type="math/tex">v_b = A \Gamma  (1 + \frac{1}{k})</script></li>
</ul>
<p>其中尺寸参数A和形状参数k可根据风电场的实测数据估算。下图左为基本风变化曲线，图右为仿真模型。</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/nomalwind.png" style="zoom:70%" ></div>
　
- 阵风：描述风速突然变化的特性，通常用来分析风电系统对电网电压波动的影响。

$$v_g = \left\{\begin{matrix}0   , t<T_1\\ \frac{v_{g max}}{2}[1 - cos(2 \pi \cdot \frac {t - T_1}{T_g})],T_1 \leq t \leq T_1 + T_g \\ 0,t > T_1 + T_g\end{matrix}\right.$$

其中$v_g$为阵风风速，$v_{g max}$为阵风峰值，$T_1$为阵风开始时间，$T_g$为阵风周期。下图左为阵风风速随时间变化曲线，图右为仿真模型，设$v_{gmax} = 6m/s$，$T_1 = 0.03s$，$T_g = 0.05s$。

<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/zhenfeng.png" style="zoom:100%" ></div>

<ul>
<li>渐变风：顾名思义，渐变的特性</li>
</ul>
<script type="math/tex; mode=display">v_g = \left\{\begin{matrix}0   , t<T_{r1}, t>T_{r2} + T\\ v_{rmax} \frac{t-T_{r1}}{T_{r2}-T_{r1}}, T_{r1} \leq t \leq T_{r2} \\ v_{rmax},T_{r2}< t < T_{r2} + T \end{matrix}\right.</script><p>式中，$v_r$为渐变风速，$V_{rmax}$为渐变风峰值，T为渐变风持续时间，$T_{r1}$为渐变风启动时间，$T_{r2}$为渐变风结束时间。下图左为渐变风风速随时间变化曲线，图右为仿真模型，设$v_{rmax} = 6m/s$，$T_1 = 0.04s$，$T_g = 0.05s$。</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/jianbianfeng.png" style="zoom:100%" ></div>

<ul>
<li>随机风：描述特定高度上风速变化的随机特性：<script type="math/tex">v_t = v_{tmax}R_{andom}(-1,1)cos(\omega_v + \phi_v)</script></li>
</ul>
<p>式中$v_{tmax}$为最大随机风速，$R_{andom}$为-1到1之间均匀分布的随机变量，$\omega_v$为风速波动的平均距离，$ \phi_v$为$0 - 2 \pi$之间服从均匀概率分布的随机量，下图为仿真模型。</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/suijifeng.png" style="zoom:60%" ></div>

<p>综合模型为：</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/zonghe.png" style="zoom:60%" ></div>

<h4 id="风力发电机组的启动模型"><a href="#风力发电机组的启动模型" class="headerlink" title="风力发电机组的启动模型"></a>风力发电机组的启动模型</h4><p>在风轮机的启动模型中，就存在上文所说到的betz极限的应用，风轮机的功率系数$C_p$与叶尖速比$\lambda$和叶片桨距角$\beta$有关<script type="math/tex">C_p = 0.5(\frac{rC_f}{\lambda}-0.022 \beta - 2)e^{-0.255 \frac{rC_f}{\lambda}}</script><br>式中$C_f$为叶片设计常数，取3，r取12。由上文可知，某一确定的桨距角$\beta$，$C_p$有一极大值存在，因此在风力机运行的时候不能保证酥油的风速下都能产生最大的功率输出。$C_p$的仿真模型如下所示。</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/monibetz.png" style="zoom:60%" ></div>

<p>一台风轮半径为R的风轮机，当风速为v的时候，其产生的机械功率和机械转矩分别为：</p>
<script type="math/tex; mode=display">P_m = \frac{1}{2} \rho \pi R^2 C_p(\beta,\lambda) v^3</script><script type="math/tex; mode=display">T_m = \frac{P_m}{\omega} = \frac{1}{2} \rho \pi R^3 C_p(\beta,\lambda) \frac{v^2}{\lambda}</script><p>其中叶尖速比$\lambda = \frac{\omega R}{v}$，$\rho$为空气密度，即在常温下，为1.205$kg/m^3$，$\omega$为叶片旋转速度，实际上为15r/min—20r/min，仿真时取后者。因此风力仿真模型为：</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/chuandong.png" style="zoom:60%" ></div>

<h4 id="传动齿轮模型"><a href="#传动齿轮模型" class="headerlink" title="传动齿轮模型"></a>传动齿轮模型</h4><p>风力发电传动系统的作用是把原动部分的运动转变为执行部分所需的机械动作，即把风通过风力机所产生的气动转矩变为发电机侧的机械转矩。</p>
<p>因此传动系统是能量传输的纽带，同时传动系统的运动取决于驱动力及阻力的特性。忽略转轴的倔强系数、阻尼因数，可知风力机转轴到发电机转子之间的机械传动部分的数学方程为:</p>
<script type="math/tex; mode=display">T_{\omega t} - T_{ls} = J_{\omega t} \frac{d \omega_t}{dt}</script><script type="math/tex; mode=display">T_{ls} = K_g  T_{hs}</script><p>其中$J_{\omega t}$，$\omega$分别为风机的转动惯量和机械转速，$ T_{ls} ,T_{hs}$分别是经过传动齿轮低速轴和高速轴上的机械转矩，$K_g$为齿轮箱的变比。</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/chilun.png" style="zoom:50%" ></div>

<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/chilunmoni.png" style="zoom:70%" ></div>

<h4 id="三相同步发电机模型"><a href="#三相同步发电机模型" class="headerlink" title="三相同步发电机模型"></a>三相同步发电机模型</h4><p>本文所使用的的发电机模块是simulink中的PMSM模块，其中集成了传动模型和感应电机模型</p>
<ul>
<li>传动模型：当气动转矩$T_a$和电磁转矩$T_e$发生变化时，风力发电机风轮机转子将加速或减速运行，对于直驱型永磁同步发电机而言，假设转子和电机之间为刚性连接则</li>
</ul>
<script type="math/tex; mode=display">J_{eq} \frac {d \omega _m}{d t} = T_a - T_t - T_e</script><p>式中$T_l = B_m \cdot \omega _m$为传动损失，$B_m$为转动粘滞系数，$J_{eq} = J_r+ J_g$为机组等效转动惯量，$J_r ，J_g$分别为风轮机和电机的传动惯量。</p>
<ul>
<li>感应电机模型：本文中的永磁同步发电机是基于$d_q$旋转坐标轴建立起的数学模型</li>
</ul>
<script type="math/tex; mode=display">\left\{\begin{matrix} \frac{di_d}{dt} =  \frac{u_d}{L_d} -  \frac{Ri_d}{L_d} + \frac{L_q}{L_d}n_p \omega _m i_q \\ \frac{di_q}{dt} + \frac{u_q}{L_q} =  \frac{Ri_q}{L_q} + \frac{L_d}{L_q}n_p \omega _m i_d - \frac{\lambda n_p \omega _m}{L_q}\end{matrix}\right.</script><p>式中$i_d$和$i_q$分别为发电机的d轴和q轴电流，$L_d$和$L_q$分别为发电机的d轴和q轴电感，$u_d$和$u_q$分别为电压源d轴和q轴分量，R为定子电阻，$\omega _m$为转子的机械角速度，$n_p$为发电机转子极对数，$\lambda$为永磁体磁链。</p>
<p>PMSM的电磁转矩表达式为：<script type="math/tex">T_e = 1.5n_p i_q [(L_d-L_q)i_d + \lambda]</script></p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/tongbudianji.png" style="zoom:50%" ></div>

<p>其中需要注意的是，在使用<strong>PMSM</strong>模块的时候需要加上<strong>powergui</strong>模块在旁边，并且什么都不用连接才不会报错，其次是本文中的<strong>PMSM</strong>模块的驱动电路为三相逆变桥，驱动电压为100V的直流电压<sup><a href="#fn_8" id="reffn_8">8</a></sup>。</p>
<h4 id="整体建模结构图"><a href="#整体建模结构图" class="headerlink" title="整体建模结构图"></a>整体建模结构图</h4><div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/windzhengtii.png" style="zoom:100%" ></div>

<h3 id="结果与总结"><a href="#结果与总结" class="headerlink" title="结果与总结"></a>结果与总结</h3><p>下图中分别为基本风，阵风，渐变风和随机风的示波器显示图像。</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/windphoto.png" style="zoom:100%" ></div>

<p>综合风速图如下所示：</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/zonghewindphoto.png" style="zoom:50%" ></div>

<p>风力机输出的机械功率和机械转矩如下所示：</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/jixiegonglvyuzhuanju.png" style="zoom:60%" ></div>

<p>三相电流输出如下所示：</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/wind/iiii.png" style="zoom:30%" ></div>

<hr>
<p>本文在模拟的时候虽然能在一定程度上反应风能是如何变为三相电的，但是还是有很多的不足。</p>
<ul>
<li>只考虑到了能量的传递没有考虑到能量的损耗，并且本文中只是定浆距角进行讨论，实际上桨距角会随着风向风速的变化而发生变化。</li>
<li>最终结果是三相电流，并没有模拟风力发电塔基座的变压器等结构，实际上还要经过一些步骤与转换才能正式接入三相电网为千家万户供电。</li>
</ul>
<hr>
<blockquote id="fn_1">
<sup>1</sup>. 夏辑. 高油价下新能源与节能技术研发趋势[J]. 安徽科技,2008,(8):4-8<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_2">
<sup>2</sup>. 耿华,杨耕,马小亮等. 并网型风力发电机组的控制技术综述[J]. 电力电子技术, 2006, 40(6): 33-36<a href="#reffn_2" title="Jump back to footnote [2] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_3">
<sup>3</sup>. 付海涛. 变速恒频风力发电系统的建模与仿真研究[D]. 华中科技大学, 2005.<a href="#reffn_3" title="Jump back to footnote [3] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_4">
<sup>4</sup>. Betz, A. (1966) Introduction to the Theory of Flow Machines. (D. G. Randall, Trans.) Oxford: Pergamon Press.<a href="#reffn_4" title="Jump back to footnote [4] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_5">
<sup>5</sup>. 钱杰. 低风速小型永磁风力发电机叶片及支承的研究与设计[D].武汉理工大学,2010.<a href="#reffn_5" title="Jump back to footnote [5] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_6">
<sup>6</sup>. 王岩. 电机及拖动基础. [M]. 清华大学出版社, 2012.6<a href="#reffn_6" title="Jump back to footnote [6] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_7">
<sup>7</sup>. 唐钱江, 韩春成, 王萍, 王立地. 离网小型风力发电系统的建模与仿真[J]. 电网与清洁能源, 2012, 28(3): 74-78<a href="#reffn_7" title="Jump back to footnote [7] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn_8">
<sup>8</sup>. 袁雷. 现代永磁同步电机控制原理及MATLAB仿真. [M]. 北京航空航天大学出版社. 2016.4<a href="#reffn_8" title="Jump back to footnote [8] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>wind_power</category>
      </categories>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2020/07/01/java002/</url>
    <content><![CDATA[<h2 id="java入门第二章"><a href="#java入门第二章" class="headerlink" title="java入门第二章"></a>java入门第二章</h2><blockquote>
<p>这部分内容适用于大部分编程语言，适用于复习一下C语言基础</p>
</blockquote>
<a id="more"></a>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul>
<li><em>what</em>：在java源程序中凡是程序员有权利自己命名的单词都是标识符，其可以标识类名，方法名，接口名，常量名</li>
<li><em>how</em>：一个合法的标识符只能由数字，字母，下划线，美元符号组成，不能含有其他符号，并且不能用数字开头，严格区分大小写，同时关键字不能为标识符，理论上无长度限制</li>
<li><em>why</em>：最好见名知意，并准守驼峰命名方式</li>
</ul>
<blockquote>
<p><strong>类名，接口名：首字母大写，后面每个单词首字母大写</strong><br><strong>变量名，方法名：首字母小写，后面每个单词首字母大写</strong><br><strong>常量名：全部大写</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdentifierText01</span></span>&#123;<span class="comment">//IdentifierText01是一个类名，名字可以修改</span></span><br><span class="line">	<span class="comment">//main是一个方法名</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;<span class="comment">//args是一个变量名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>如上面这段程序中public，class，void等等等等都是关键字，是由SUM公司定义的 </p>
<h3 id="字面值"><a href="#字面值" class="headerlink" title="字面值"></a>字面值</h3><ul>
<li><em>what</em>：就是数据，不同于常量，字面值是java源程序的组成部分之一，包括标识符和关键字它们都是java源程序的组成部分，如：<code>10</code>,<code>100</code>,<code>3.14</code>,<code>&quot;abc&quot;</code>,<code>&#39;a&#39;</code>,<code>true</code>,<code>false</code></li>
<li>数据在现实世界当中是分门别类的，所以数据在计算机编程语言当中也是有类型的：<ul>
<li><code>10</code>,<code>100</code>属于整数型字面值</li>
<li><code>3.14</code>属于浮点型字面值</li>
<li><code>true</code>,<code>false</code>属于布尔型字面值</li>
<li><code>&quot;abc&quot;</code>,<code>&#39;a&#39;</code>属于字符串型字面值 </li>
<li><code>&#39;A&#39;</code>,<code>&#39;人&#39;</code>属于字符型字面值</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong><br><strong>java语言中所有的字符串型字面值必须使用双引号括起来，双引号是半角的</strong><br><strong>java语言中所有的字符型字面值必须使用单引号括起来，单引号是半角的</strong><br><strong>字面值即使相同可能其的物理存放地址是不相同的，每一个字面值都占用一定的内存空间</strong></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p><em>what</em>：本质上是内存中的一块空间，这块空间有数据类型，有名字，有字面值，因此变量包含<strong>数据类型、名称和字面值【数据】</strong>。变量是内存中存储数据的最基本单元</p>
<ul>
<li><p>数据类型的作用：不同的数据有不同的类型，不同的数据类型底层会分配不同大小的数据空间，同时指导程序在运行阶段应该分配多大的内存空间<strong>（动态的）</strong></p>
</li>
<li><p>变量要求其中存储的具体的<strong>数据</strong>必须和变量的<strong>数据类型</strong>一致，因此定义方法是<code>数据类型 变量名;</code>，赋值方法是<code>变量名 = 字面值;</code>，定义和赋值过程可以同时完成</p>
</li>
<li>变量可以重复访问，内存空间得到重复使用，则访问一个变量包括两种访问方式<ul>
<li>读取变量中保存的具体数值 get</li>
<li>修改变量中保存的具体数值  set</li>
</ul>
</li>
</ul>
<p><strong>java中的变量必须先声明再赋值才能访问，只有<code>int i</code>实际上内存空间并没有开辟出来，变量i并没有初始化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarTest01</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	    <span class="comment">//声明一个int类型的变量，起名i</span></span><br><span class="line">	    <span class="keyword">int</span> i;</span><br><span class="line">		<span class="comment">//开辟内存，i变量完成初始化</span></span><br><span class="line">	    i = <span class="number">100</span>;</span><br><span class="line">	    System.out.println(i);</span><br><span class="line">	    </span><br><span class="line">		i = <span class="number">200</span>;</span><br><span class="line">	    System.out.println(i);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*以下代码有错误，重复定义</span></span><br><span class="line"><span class="comment">		int i = 200;</span></span><br><span class="line"><span class="comment">		System.out.println(i);</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：<br>在方法体中的java代码，是严格遵循自上而下的顺序执行的<br>并且在一个<strong>作用域</strong>中，变量名不能重名，但是变量可以重新赋值</p>
</blockquote>
<h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><p><em>what</em>：描述变量的有效范围，出了这个范围该变量就无法访问。简单来说就是：</p>
<blockquote>
<h4 id="出了大括号就不认识"><a href="#出了大括号就不认识" class="headerlink" title="出了大括号就不认识"></a>出了大括号就不认识</h4></blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VarTest02</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注意这里的static不能去掉</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">90</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	    <span class="comment">//变量i的作用域是main方法</span></span><br><span class="line">	    <span class="comment">//在整个main中是有效的，出了大括号到下边的那个方法体内就无法被识别了</span></span><br><span class="line">	    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">	    System.out.println(i);</span><br><span class="line">	    System.out.println(k);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> a=<span class="number">0</span>;a&lt;<span class="number">10</span>;a++)&#123;</span><br><span class="line">		<span class="comment">//a变量的作用域是整个for循环，for循环结束之后，a变量的内存被释放了</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这里无法访问a变量</span></span><br><span class="line">		<span class="comment">//System.out.println(a);</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> j;</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;<span class="number">10</span>;j++)&#123;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//这里可以访问main方法中的j变量</span></span><br><span class="line">		System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dosame</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//这里无法访问main方法中的变量i</span></span><br><span class="line">	    <span class="comment">//System.out.println(i);</span></span><br><span class="line">		<span class="comment">//k是在外边大括号定义的</span></span><br><span class="line">		System.out.println(k);</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>这里注意，如果使用cmd中的javac进行编译的时候，因为注释是中文，因此可能会出现<code>编码GBK的不可映射字符</code>这个错误</strong><br><strong>错误原因是：ANSI和UTF-8编码冲突</strong><br><strong>解决办法是：编译的时候使用<code>javac -encoding UTF-8 文件名.java</code></strong>或者使用其他编译软件如：eclipse</p>
</blockquote>
<h4 id="变量的分类"><a href="#变量的分类" class="headerlink" title="变量的分类"></a>变量的分类</h4><p>根据位置进行分类</p>
<ul>
<li>局部变量：在方法体中声明的变量</li>
<li>成员变量（全局变量）：在方法体外【类体之内】声明的变量</li>
</ul>
<p>在不同的作用域中变量名是可以相同的，在不同的作用域中，变量名不能重名</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><em>what</em>&amp;<em>how</em>：程序中的不同数据都有相关类型，不同数据类型所占用的内存空间大小不同。因此数据类型是指导JVM在运行程序的时候给该数据分配多大的空间</p>
<ul>
<li>基本数据类型【<strong>四大类八小种</strong>】<ul>
<li>整数型：byte（1字节=8个bit（一个bit就是一个二进制位）【-127 ~ 128】），short（2字节【-32768 ~ 32767】），int（4字节），long（8字节）</li>
<li>浮点型：float（4字节），double（8字节）</li>
<li>布尔型：boolen（1字节）</li>
<li>字符型：char：<code>&#39;a&#39;</code>（2字节【0 ~ 65535】）</li>
</ul>
</li>
<li>引用数据类型<ul>
<li><strong>字符串</strong>：<code>&quot;abc&quot;</code></li>
<li>接口</li>
<li>类</li>
<li>数组……</li>
</ul>
</li>
</ul>
<blockquote>
<p>一字节表示范围为-128~127【原码，反码，补码】<br>这里可以把二进制复习一下，后边会在数电复习中施工</p>
</blockquote>
<pre><code>    &#39;a&#39;   ------(按照ASCII解码)-------&gt;        0110 0001
    0110 0001  ------(按照ASCII编码)-------&gt;    &#39;a&#39;
</code></pre><p>编码和解码的时候采用同一套对照表，不会出现乱码，当解码和编码的时候采用的是不同的对照表，会出现乱码问题。</p>
<p>注意：short和char所表示的种类总数是一样的，只不过char可以表示更大的正整数，是因为char没有负数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataTypeTest</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//注意这里的static不能去掉</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">90</span>;</span><br><span class="line">	<span class="comment">//成员变量没有手动赋值时系统会默认赋值，八种数据类型的默认值是向0看齐【局部变量不会】</span></span><br><span class="line">	<span class="comment">//因此变量还是遵循先声明，后赋值，再访问</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> f;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	    <span class="comment">//i为局部变量</span></span><br><span class="line">	    <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">	    </span><br><span class="line">		System.out.println(i);    <span class="comment">//100</span></span><br><span class="line">	    System.out.println(k);    <span class="comment">//90</span></span><br><span class="line">		System.out.println(f);    <span class="comment">//0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h4><blockquote>
<ul>
<li>对于char类型其中单引号中间只能有一个标识一个字符</li>
<li>对于转译字符<code>\</code>具转译功能，则可以存在两个标识，为一个字符，比如：<code>\n</code>换行符；<code>\t</code>制表，同时注意输出反斜杠或者单引号时的写法</li>
<li><code>print</code>表示输出不换行，<code>println</code>输出之后换行</li>
<li>同时在JDK中自带的native2ascii.exe命令，可以将文字转换成Unicode编码方式</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataTypeTest01</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="comment">//定义一个char类型的变量，起名c，同时赋值为'a'</span></span><br><span class="line">	    <span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line">		System.out.println(c);  </span><br><span class="line">		 </span><br><span class="line">		<span class="comment">//一个中文占用两个字节，char类型正好是2个字节，因此java中的char类型可以存储一个中文字符</span></span><br><span class="line">	    <span class="keyword">char</span> x = <span class="string">'国'</span>;</span><br><span class="line">		System.out.println(x);  </span><br><span class="line"></span><br><span class="line">		<span class="comment">//'ab',"a"都是字符串，因此都不能用char进行声明</span></span><br><span class="line">		<span class="comment">//char y = 'ab';</span></span><br><span class="line">		<span class="comment">//char z = "a"</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//转义字符的换行符</span></span><br><span class="line">		<span class="keyword">char</span> c2 = <span class="string">'\n'</span>;</span><br><span class="line">		System.out.println(c2);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//输出\,第一个反斜杠具有转义功能，将第二个反斜杠转义成普通的反斜杠字符</span></span><br><span class="line">		<span class="comment">//同理输出'，则为c4 = '\''</span></span><br><span class="line">		<span class="keyword">char</span> c3 = <span class="string">'\\'</span>;</span><br><span class="line">		System.out.println(c3);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>java语言中的“整数型字面值”被默认当做int类型来处理，要是让这个“整数型字面值”被当做long类型来处理的话，需要在“整数型字面值”后边添加<code>L</code></li>
<li>java语言中的“整数型字面值”有三种表示方式<ul>
<li>十进制【是一种缺省默认的方式】</li>
<li>八进制【在编写八进制“整数型字面值”时<strong>需要以0为开始</strong>】</li>
<li>十六进制【在编写十六进制“整数型字面值”时<strong>需要以0x为开始</strong>】<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">		<span class="keyword">int</span> b = <span class="number">010</span>;<span class="comment">//因为是0开头所以是八进制</span></span><br><span class="line">		<span class="keyword">int</span> c = <span class="number">0x10</span>;<span class="comment">//因为是0x开头所以后边是十六进制</span></span><br><span class="line"></span><br><span class="line">		System.out.println(a+b+c);<span class="comment">//34</span></span><br><span class="line">		<span class="comment">//123整数型字面值是int类型，i的变量声明也是int类型，所以不存在类型转换</span></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">123</span>;</span><br><span class="line">		System.out.println(i);</span><br><span class="line">		<span class="comment">//456整数型字面值被当做int类型，占用4个字节，x变量在声明的时候是long类型，占用8字节，因此存在类型转换，int（小容量）----&gt;long（大容量），</span></span><br><span class="line">		<span class="comment">//小容量自动转换为大容量称为自动类型转换</span></span><br><span class="line">		<span class="keyword">long</span> j = <span class="number">456</span>;</span><br><span class="line">		System.out.println(j);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//2147483648超过了int定义的最大值但是在编译的时候依然被当做int类型来处理，所以会报错</span></span><br><span class="line">		<span class="comment">//解决错误，在字面值前一上来就当做long类型来处理，在字面值后边加`L`，因此这时不存在数据类型转换</span></span><br><span class="line">		<span class="keyword">long</span> z = <span class="number">2147483648L</span>;</span><br><span class="line">		System.out.println(z);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>电力系统分析</title>
    <url>/2020/07/01/controlelectricsystem/</url>
    <content><![CDATA[<h2 id="电力系统分析"><a href="#电力系统分析" class="headerlink" title="电力系统分析"></a>电力系统分析</h2><p>课程分为《<strong>电力系统稳态分析</strong>》和《<strong>电力系统暂态分析</strong>》</p>
<a id="more"></a>
<p>其中电力系统稳态分析主要介绍</p>
<ul>
<li>电力系统基本概念；</li>
<li>正常状态下系统各元件参数等值电路；</li>
<li>正常情况运行状态的分析计算；</li>
<li>正常情况下的运行状态调整。</li>
</ul>
<p>电力系统暂态分析</p>
<ul>
<li>电力系统短路时的基本概念；</li>
<li>电力系统三相短路电流分析计算；</li>
<li>电力系统不对称短路电流分析计算；</li>
<li>简单电力系统的静态稳定和暂态稳定。</li>
</ul>
<blockquote>
<p>先从电力系统稳态分析开始学起吧</p>
</blockquote>
<h3 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h3><blockquote>
<p>我国的电力系统发展经历了三个阶段，分别是1882年—1937—1949—至今，每个阶段都有标志性的事件和对应的特点，而今已经形成了500kv和300kv的主干网架，西北电网750kV线路已投入运行，1000kV电网正在规划中；我国电网进入了远距离、超高压、跨大地区输电的阶段。目前，我国已形成东北、华北、华东、华中、西北、南方共6个跨省电网以及新疆、海南和西藏3个独立省网，全国联网也指日可待。</p>
</blockquote>
<h4 id="商业化运行"><a href="#商业化运行" class="headerlink" title="商业化运行"></a>商业化运行</h4><p>在1998年成立电网公司，在2010年前全面实行厂网分开，竞价上网，在2010年后实现发，输，配三个环节分开</p>
<p>我国的电力工业发展前景</p>
<ul>
<li>高参数（高温、高压、超临界、单机容量）</li>
<li>大容量远距离高压输电、大系统互联</li>
<li>高度自动化，电力市场化</li>
<li>分布式发电</li>
</ul>
<blockquote>
<p>风电发展的速度超过了其他清洁能源的发展</p>
</blockquote>
<h1 id="施工ing"><a href="#施工ing" class="headerlink" title="施工ing"></a>施工ing</h1><h4 id="电力系统组成"><a href="#电力系统组成" class="headerlink" title="电力系统组成"></a>电力系统组成</h4><p>电力系统是由发电厂、</p>
<h3 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h3>]]></content>
      <categories>
        <category>PowerSystemAnalysis</category>
      </categories>
  </entry>
  <entry>
    <title>Java学习笔记</title>
    <url>/2020/07/01/java001/</url>
    <content><![CDATA[<h2 id="Java初体验"><a href="#Java初体验" class="headerlink" title="Java初体验"></a>Java初体验</h2><blockquote>
<p>计算机包括两部分：<br>硬件：鼠标、键盘、显示器、主机箱内部的CPU、内存条、硬盘等…<br><strong>注意</strong>：计算机只有硬件是无法工作的，需要软件驱动硬件才能工作。<br>软件：包括系统软件和应用软件<br><strong>系统软件</strong>：直接和硬件交互的软件，例如：window7，linux操作系统<br><strong>应用软件</strong>：应用软件通常运行在系统软件中，比如QQ运行在windows操作系统上</p>
</blockquote>
<p>我们通常说的软件开发一般是指使用计算机编程语言完成<strong>应用程序</strong>的开发</p>
<p><del>Java是世界上最好的语言</del></p>
<a id="more"></a>
<hr>
<p>[TOC]</p>
<hr>
<h3 id="准备技能"><a href="#准备技能" class="headerlink" title="准备技能"></a>准备技能</h3><h4 id="基本DOS命令"><a href="#基本DOS命令" class="headerlink" title="基本DOS命令"></a>基本DOS命令</h4><ul>
<li>需要复制上边的内容是win10下左键选中直接右键</li>
<li><p><code>dir</code> 列出当前子目录文件</p>
</li>
<li><p><code>cd</code>表示改变目录<code>..</code>，<code>\</code>，<code>d:回车</code></p>
</li>
</ul>
<blockquote>
<p>路径包括绝对路径和相对路径<br><strong>绝对路径</strong>：表示该路径从某个磁盘的盘符下作为出发点的路径<br><strong>相对路径</strong>：表示该路径从当前所在的路径下作为出发点的路径</p>
</blockquote>
<ul>
<li><p><code>mkdir abc</code>：ake directory（创建目录）创建一个目录，起名abc</p>
</li>
<li><p>del命令，删除一个或者多个文件<br>删除T1.class文件   <code>C:\Users\Administrator&gt;del T1.class</code><br>删除所有.class结尾的文件，支持模糊匹配<code>C:\Users\Administrator&gt;del *.class</code></p>
</li>
<li><p><code>IP</code>A计算机在网络当中要想定位到（连接到）B计算机，那么必须要先知道B计算机的IP地址，IP地址也可以看做计算机在同一个网络当中的身份证号（唯一标识）。</p>
</li>
<li><code>ipconfig（ip地址的配置信息。）</code><br>ipconfig /all 该命令后面添加一个/all参数可以查看更详细的网络信息。这个详细信息中包括网卡的物理地址，例如：70-8B-CD-A7-BA-25 这个物理地址具有全球唯一性。物理地址通常叫做MAC地址。</li>
</ul>
<ul>
<li>linux系统后续补充</li>
</ul>
<h4 id="计算机基本操作"><a href="#计算机基本操作" class="headerlink" title="计算机基本操作"></a>计算机基本操作</h4><p>回到行首：<code>home</code>键<br>回到行尾：<code>end</code>键</p>
<p>当光标在行尾，怎么选中一行？<code>shift + home</code>键<br>当光标在行首，怎么选中一行？<code>shift + end</code>键</p>
<p>回到文件头：<code>ctrl + home</code><br>回到文件尾：<code>ctrl + end</code></p>
<hr>
<h4 id="计算机语言发展史"><a href="#计算机语言发展史" class="headerlink" title="计算机语言发展史"></a>计算机语言发展史</h4><ul>
<li>第一代语言：机器语言，主要编写二进制代码，以打孔机为代表</li>
<li>第二代语言：低级语言/汇编语言，已经引入了一些英语单词，例如变量赋值采用mv</li>
<li>第三代语言：高级语言，几乎与人类语言相通，看代码识文意</li>
</ul>
<h4 id="Java发展史"><a href="#Java发展史" class="headerlink" title="Java发展史"></a>Java发展史</h4><ul>
<li>Java诞生于1995年</li>
<li>其实在1995年之前sum公司（太阳微电子公司：该公司目前被Oracle（甲骨文：做数据库的）收购了）为了抢占智能电子消费产品市场，派James Gosling领导团队开发了一个Oak（橡树）语言</li>
<li>1996年：JDK1.0诞生，其中JDK是Java开发工具包，目前Java包括三大块<blockquote>
<p><strong>JavaSE（Java标准版）</strong>：基础，要学java，必须先学习SE。基础语法+基础库<br><strong>JavaEE（Java企业版）</strong>：专门为企业开发软件，为企业提供解决方案。例如：OA办公系统，保险行业的系统，金融行业的系统，医院系统….<br><strong>JavaME（Java微型版）</strong>：专门为微型设备做嵌入式开发的。</p>
</blockquote>
</li>
</ul>
<h4 id="Java语言特性【开源、免费、纯面向对象、跨平台】"><a href="#Java语言特性【开源、免费、纯面向对象、跨平台】" class="headerlink" title="Java语言特性【开源、免费、纯面向对象、跨平台】"></a>Java语言特性【开源、免费、纯面向对象、跨平台】</h4><ul>
<li><strong>简单性</strong>：在Java语言当中真正操作内存的是：JVM（Java虚拟机）所有的java程序都是运行在Java虚拟机当中的。而Java虚拟机执行过程中再去操作内存。对于C或者C++来说程序员都是可以直接通过指针操作内存的。Java语言屏蔽了指针概念，程序员不能直接操作指针，或者说程序员不能直接操作内存。</li>
</ul>
<p><strong>Java语言底层是c++实现的</strong></p>
<blockquote>
<p>这种方式有优点也有缺点：<br>优点：不容易导致内存泄漏。（简单了。）<br>缺点：效率问题，包括驾驭感比较差。</p>
</blockquote>
<ul>
<li><p><strong>java是堪称完全面向对象的。</strong>面向对象更容易让人理解，人类通常是以对象的方式认知世界的。</p>
</li>
<li><p><strong>健壮性</strong>自动垃圾回收机制（GC机制）。Java不容易导致内存的泄漏。C++或者C语言使用不当时很容易导致内存泄漏。</p>
</li>
<li><p><strong>可移植性</strong>Java程序可以做到一次编译，到处执行，win和linux和Mac OS均可任意运行。<br>Java本身是不能直接和操作系统直接交互的，主要是因为有了JVM（不同系统有不同版本），虚拟机的概念套了一层外壳之后便可以实现任意移植。</p>
</li>
</ul>
<blockquote>
<p>JVM这种机制实现了跨平台，那么这种机制优点和缺点分别是什么？<br>优点：一次编写到处运行，可以跨平台。<br>缺点：麻烦。对于运行java程序来说必须先有一个JVM。就像你要想在网页上看视频，你必须先安装一个flash是一样的。<br>Java语言可以编写病毒吗？可以。但是很难让用户中毒。中毒的一般都是java程序员。所以很少有人编写java的病毒脚本。</p>
</blockquote>
<hr>
<h3 id="Java的加载与运行"><a href="#Java的加载与运行" class="headerlink" title="Java的加载与运行"></a>Java的加载与运行</h3><blockquote>
<p>从编译到运行</p>
</blockquote>
<ul>
<li>编译阶段：主要任务是检查Java源程序是否符合Java语法则可以生成正常的字节码文件（.class）不符合的话就不会生成</li>
<li>字节码文件中不失纯粹的二进制，这种文件无法在操作系统当中直接执行</li>
</ul>
<hr>
<h4 id="编译阶段的过程"><a href="#编译阶段的过程" class="headerlink" title="编译阶段的过程"></a>编译阶段的过程</h4><ul>
<li>在硬盘的某个位置（随意），新建一个xxx.java文件，后在xxx.java文件中编写<strong>符合java语法规则的</strong>源代码，保存并使用编译器（javac【JDK安装后自带】）对xxx.java文件进行编译。</li>
<li>javac的使用规则，Java源文件的路径，并在DOS窗口使用，javac是Java的编译器工具/命令</li>
<li>一个Java源文件可以编译生成多个.class文件（<strong>类的概念</strong>）这些.class 文件是最终要执行的文件，所以说class文件生成之后Java源文件即使删除了也不影响程序的执行</li>
<li>但是最好<strong>不要删除源代码</strong>。因为有可能执行结果不是需要的，当执行结果不是你需要的时候，可以重新打开源代码进行修改，然后重新编译生成新的字节码，再重新执行。这样会有新的执行效果。</li>
</ul>
<h4 id="运行阶段的过程【可以在其他操作系统中使用，跨平台】"><a href="#运行阶段的过程【可以在其他操作系统中使用，跨平台】" class="headerlink" title="运行阶段的过程【可以在其他操作系统中使用，跨平台】"></a>运行阶段的过程【可以在其他操作系统中使用，跨平台】</h4><blockquote>
<p>JDK安装之后，除了自带一个javac.exe之外，还有一工具/命令，叫做Java.exe，后者主要负责运行阶段</p>
<p>java.exe在DOS窗口中使用，例如硬盘上有一个A.class，那么就这样：<strong>java A</strong>，而不要<del>java A.class</del>（A是类名）</p>
</blockquote>
<ul>
<li>打开DOS命令窗口</li>
<li>输入：java A</li>
<li>java.exe命令会启动java虚拟机（JVM），JVM会启动类加载器ClassLoader</li>
<li>ClassLoader会去硬盘上搜索A.class文件，找到该文件则将该字节码文件装载到JVM中</li>
<li>JVM将A.class字节码文件解释成二进制10001010这样的二进制数</li>
<li>然后操作系统执行二进制和底层硬件平台进行交互</li>
</ul>
<h4 id="第一个java程序"><a href="#第一个java程序" class="headerlink" title="第一个java程序"></a>第一个java程序</h4><blockquote>
<p>JDK（开发环境）包含JRE（运行环境）包含JVM（虚拟机）</p>
</blockquote>
<p>JDK目录中的bin相对重要，里边都是各种命令</p>
<p><strong>这里要介绍一下环境变量</strong></p>
<p>win操作系统是如何搜索硬盘的某个命令的呢</p>
<ul>
<li>首先会从当前目录下搜索，如果当前目录搜索不到则从环境变量path指定的路径当中搜索某个命令</li>
<li>如果都搜索不到，则会说不是内部或外部命令，也不是可运行程序</li>
</ul>
<p>path环境变量与java语言没有关系，path环境变量时属于win操作系统的，用来指路</p>
<p>也可以专门为ClassLoader去指定的路径下加载字节码文件，这时候则需要配置环境变量classpath，这里的classpath这属于java语言中的环境变量，不属于win操作系统。classpath是给ClassLoader类加载器指路的</p>
<p>因此当classpath环境变量配置为某个指定的路径之后，类加载器只去指定的路径下加载字节码文件</p>
<hr>
<h4 id="一切始于HelloWorld"><a href="#一切始于HelloWorld" class="headerlink" title="一切始于HelloWorld"></a>一切始于HelloWorld</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public表示公开的</span></span><br><span class="line"><span class="comment">class表示定义一个类</span></span><br><span class="line"><span class="comment">HelloWorld表示一个类名</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span></span>&#123;<span class="comment">//表示定义了一个公开的类，起名为HelloWorld</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//类体</span></span><br><span class="line">	<span class="comment">//类体中不允许直接编写java语句【除声明变量之外】</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		public表示公开的</span></span><br><span class="line"><span class="comment">		static表示静态的</span></span><br><span class="line"><span class="comment">		void表示空</span></span><br><span class="line"><span class="comment">		main表示方法名是main</span></span><br><span class="line"><span class="comment">		（String[] args）是一个main方法的形式参数列表</span></span><br><span class="line"><span class="comment">		以下方法是一个程序的主方法，是程序的执行入口，是SUN公司规定的固定的编写方法</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;<span class="comment">//定义一个公开的静态的主方法，是程序的执行入口</span></span><br><span class="line">	    <span class="comment">//方法体</span></span><br><span class="line">	    <span class="comment">//java语句，全角半角分清</span></span><br><span class="line">	    <span class="comment">//向控制台输出一段信息</span></span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>java注释：<br>1.单行注释<code>//</code><br>2.多行注释<code>/*     */</code><br>3.javadoc注释<code>/**     */</code><br>javadoc注释是最终可以解析，提取，并最终生成帮助文档，是由javadoc.exe执行</p>
</blockquote>
<p><strong>public class和class的区别</strong></p>
<ul>
<li>一个java源文件中可以定义多个class</li>
<li>一个java源文件当中public的class不是必须的</li>
<li>一个class会定义生成一个.class字节码文件</li>
<li>一个java源文件中定义公开的类的话，public的class只能有一个，并且该类名称必须和java源文件名称一致</li>
<li>每一个class当中都可以编写main方法，都可设定程序的入口想执行B.class中的main方法只需要<code>java B</code>，但是当在命令窗口中执行<code>java Hello</code>，那么要求Hello.class当中必须有主方法，没有主方法会出现报错，找不到主方法入口</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>理解java的加载与运行</li>
<li>能够自己搭建java的开发环境</li>
<li>能够独立编写HelloWorld程序，编译并运行</li>
<li>掌握环境变量path的原理以及如何配置</li>
<li>掌握环境变量classpath的原理以及如何配置</li>
<li>java注释</li>
<li>public class和class的区别</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>hexo美化--next主题</title>
    <url>/2020/04/06/nextthemefirst/</url>
    <content><![CDATA[<h1 id="hexo美化—next主题"><a href="#hexo美化—next主题" class="headerlink" title="hexo美化—next主题"></a>hexo美化—next主题</h1><h4 id="这里我们已经搭建起我们的个人博客了，那么让它赏心悦目便提上了日程。"><a href="#这里我们已经搭建起我们的个人博客了，那么让它赏心悦目便提上了日程。" class="headerlink" title="这里我们已经搭建起我们的个人博客了，那么让它赏心悦目便提上了日程。"></a><a href="https://asmikezheng.github.io/2020/03/13/hexofirst/#more" target="_blank" rel="noopener">这里</a>我们已经搭建起我们的个人博客了，那么让它赏心悦目便提上了日程。</h4><blockquote>
<p>产生快感的叫做美，产生不快感的叫做丑。                             ——沃尔夫</p>
</blockquote>
<a id="more"></a>
<p><strong>好看又好用的主题推荐</strong>：界面很美的Sakura和Butterfly，3-hexo适合博文比较多的同学，以及我们今天的主角next，插件很多并且简洁</p>
<blockquote>
<p>那让我们开始吧</p>
</blockquote>
<h3 id="1-首先咱们先来看看它的官方网站的使用说明"><a href="#1-首先咱们先来看看它的官方网站的使用说明" class="headerlink" title="1. 首先咱们先来看看它的官方网站的使用说明"></a>1. 首先咱们先来看看它的官方网站的使用说明</h3><p><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">点这里</a>进入其官网的<strong>使用文档</strong>可以看到其中提供了：</p>
<ul>
<li>主题的下载与启用</li>
<li>三种样式的选择和语言的更换</li>
<li>设置菜单，侧栏，头像，作者昵称和站点描述</li>
<li>以及第三方服务，如：阅读统计次数等</li>
</ul>
<p><strong>有一点需要注意</strong>，如图在<code>主题配置文件</code>中设定菜单内容时，将句首的<code>#</code>删去既是启用这一菜单，让我们看注释</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).</span></span><br><span class="line"><span class="comment"># Usage: `Key: /link/ || icon`</span></span><br><span class="line"><span class="comment"># Value before `||` delimeter is the target link.</span></span><br><span class="line"><span class="comment"># Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.</span></span><br></pre></td></tr></table></figure>
<h2 id="注意注意注意"><a href="#注意注意注意" class="headerlink" title="注意注意注意"></a>注意注意注意</h2><p><strong>我们可以知道，以<code>categories: /categories/|| th</code>为例，第一个categories是指<code>Usage</code>，第二个是指其目标链接，因此而后的<code>/</code>后边就</strong>不可以<strong>有空格，</strong></p>
<p><strong>如果有空格则在预览时会出现这样的地址<code>http://localhost:4000/categories/%20/</code>其中<code>/%20</code>就是这个空格造成的，因此要将其删去。</strong></p>
<hr>
<p>通过以上的配置已经可以让博客具有更强的实用性和拥有更强大的功能，但是我们还希望让它更活泼，那么接下来的这些设置可能会满足你。</p>
<h3 id="2-个性化设置"><a href="#2-个性化设置" class="headerlink" title="2. 个性化设置"></a>2. 个性化设置</h3><h4 id="2-1-动态背景"><a href="#2-1-动态背景" class="headerlink" title="2.1 动态背景"></a>2.1 动态背景</h4><p>next主题在5.1.1以上的版本的话只需要打开<code>主题配置文件</code>找到这段代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Canvas-nest</span><br><span class="line">canvas_nest: ture</span><br><span class="line"></span><br><span class="line"># three_waves</span><br><span class="line">three_waves: false</span><br><span class="line"></span><br><span class="line"># canvas_lines</span><br><span class="line">canvas_lines: false</span><br><span class="line"></span><br><span class="line"># canvas_sphere</span><br><span class="line">canvas_sphere: false</span><br></pre></td></tr></table></figure>
<p>这里有四种动态背景的样式，选择自己喜欢的一种把<code>false</code>改成<code>ture</code>即可。</p>
<h4 id="2-1-打赏功能"><a href="#2-1-打赏功能" class="headerlink" title="2.1 打赏功能"></a>2.1 打赏功能</h4><p>……未完待续</p>
<blockquote>
<p>等慢慢更新好了</p>
</blockquote>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>树莓派初体验</title>
    <url>/2020/03/16/Raspberryfirst/</url>
    <content><![CDATA[<h1 id="树莓派（不是一种食物）"><a href="#树莓派（不是一种食物）" class="headerlink" title="树莓派（不是一种食物）"></a>树莓派（不是一种食物）</h1><h4 id="关于树莓派系统搭建和开机"><a href="#关于树莓派系统搭建和开机" class="headerlink" title="关于树莓派系统搭建和开机"></a>关于树莓派系统搭建和开机</h4><blockquote>
<p>本文基于win10系统，针对树莓派4B的系统搭建（同时适用于树莓派3B和3B+）</p>
</blockquote>
<a id="more"></a>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>树莓派</strong>英文名(Raspberry Pi)，是为计算机编程而设计的只有手掌大小的卡片式电脑，其系统基于Linux。随着Windows 10 IoT的发布，我们也可以使用运行Windows系统的树莓派。</p>
<p><strong>树莓派到底能干什么</strong><br>Our mission is to put the power of computing and digital making into the hands of people all over the world. We do this so that more people are able to harness the power of computing and digital technologies for work, to solve problems that matter to them, and to express themselves creatively.                                         ——<a href="https://www.raspberrypi.org/" target="_blank" rel="noopener">树莓派官网</a></p>
<hr>
<p><strong>树莓派型号对比</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">Raspberry Pi 3B</th>
<th style="text-align:center">Raspberry Pi 3B+</th>
<th style="text-align:center">Raspberry Pi 4B</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SOC</td>
<td style="text-align:center">Broadcom BCM2837</td>
<td style="text-align:center">Broadcom BCM2837B0</td>
<td style="text-align:center">Broadcom BCM2711</td>
</tr>
<tr>
<td style="text-align:center">CPU</td>
<td style="text-align:center">64-位 1.2GHz四核</td>
<td style="text-align:center">64-位 1.4GHz四核</td>
<td style="text-align:center">64-位 1.5GHz四核</td>
</tr>
<tr>
<td style="text-align:center">GPU</td>
<td style="text-align:center">BVC IV@400MHz</td>
<td style="text-align:center">BVC IV@400MHz</td>
<td style="text-align:center">BVC VI@500MHz</td>
</tr>
<tr>
<td style="text-align:center">蓝牙</td>
<td style="text-align:center">蓝牙4.1</td>
<td style="text-align:center">蓝牙4.2</td>
<td style="text-align:center">蓝牙5.0</td>
</tr>
<tr>
<td style="text-align:center">USB接口</td>
<td style="text-align:center">USB2.0*4</td>
<td style="text-align:center">USB2.0*4</td>
<td style="text-align:center">USB2.0<em>2/USB3.0</em>2</td>
</tr>
<tr>
<td style="text-align:center">HDMI</td>
<td style="text-align:center">标准HDMI*1</td>
<td style="text-align:center">标准HDMI*1</td>
<td style="text-align:center">micro HDMI*2支持4k60</td>
</tr>
<tr>
<td style="text-align:center">有线网络</td>
<td style="text-align:center">10/100Mb/s以太网</td>
<td style="text-align:center">USB 2.0千兆以太网</td>
<td style="text-align:center">真千兆以太网(网口可达)</td>
</tr>
<tr>
<td style="text-align:center">以太网Poe</td>
<td style="text-align:center">无</td>
<td style="text-align:center">通过额外的HAT以太网供电</td>
<td style="text-align:center">通过额外的HAT以太网供电</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>ps.通过上图我觉得是等等党的胜利hhh</p>
</blockquote>
<hr>
<p><strong>准备工作</strong>：</p>
<ul>
<li><strong>准备一张空的SD卡，官方推荐是8G以上</strong></li>
<li><strong>一根网线</strong></li>
<li><strong>格式化工具SDFormatter</strong>：在<a href="https://www.sdcard.org/downloads/formatter/eula_windows/" target="_blank" rel="noopener">这里</a>下载（滑到最下边点击accept接受协议可下载)</li>
<li><strong>烧写镜像的工具Win32DiskImager</strong>：在<a href="https://sourceforge.net/projects/win32diskimager/" target="_blank" rel="noopener">这里</a>下载</li>
</ul>
<blockquote>
<p>那让我们开始吧</p>
</blockquote>
<h3 id="1-树莓派官方镜像的下载与安装"><a href="#1-树莓派官方镜像的下载与安装" class="headerlink" title="1. 树莓派官方镜像的下载与安装"></a>1. 树莓派官方镜像的下载与安装</h3><h4 id="1-1树莓派官方镜像"><a href="#1-1树莓派官方镜像" class="headerlink" title="1.1树莓派官方镜像"></a>1.1树莓派官方镜像</h4><p>进入<a href="https://www.raspberrypi.org/downloads/" target="_blank" rel="noopener">树莓派官网</a>的下载界面，下边给出了树莓派的两种官方推荐的操作系统，分别是Raspberry和Noobs，我们选择前者进行安装，点击进入后我们选择第一个，如图：<br><img src="https://raw.githubusercontent.com/Asmikezheng/photo/raspberry/raspberrysystem.png" alt="raspberry"><br>因为里边预装了Python，Java，Scratch等编程教育软件和图形化桌面。</p>
<p>下载好本地解压之后我们得到了一个<code>.img</code>的镜像文件</p>
<blockquote>
<p><strong>注</strong>：如果还是压缩文件或者不能正常显示，说明是压缩软件本身需要设计，进入压缩软件设置界面，如图将img文件前的对勾去掉。</p>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/raspberry/select.png" style="zoom:50%" ></div>

</blockquote>
<h4 id="1-2镜像的烧写"><a href="#1-2镜像的烧写" class="headerlink" title="1.2镜像的烧写"></a>1.2镜像的烧写</h4><ul>
<li>将sd卡插入电脑，使用专门的格式化工具SDFormatter，格式化内存卡。</li>
<li>将已经下载好的Win32DiskImager安装后运行</li>
</ul>
<div  align="center"> <img src="https://raw.githubusercontent.com/Asmikezheng/photo/raspberry/win32disk.png" style="zoom:80%" ></div>

<ul>
<li>1处选择之前下载好的镜像文件，2处选择SD卡，3前两步选好后，点击write开始烧写。</li>
<li>等待烧录完成，拔掉SD卡，插入树莓派上电，系统会自动安装完成。</li>
</ul>
<blockquote>
<p><strong>注</strong>：烧录完成后，win系统可能会因为无法识别Linux分区格式而提示用户格式化，此时不要点格式化！不要点格式化！不要点格式化！直接点取消就可以了。如果点了格式化，树莓派会因为丢失系统文件而无法开机，需要重新烧录IMG镜像文件。</p>
</blockquote>
<h4 id="此时树莓派的安装系统已经完成，如果有显示的同学可直接进入树莓派系统"><a href="#此时树莓派的安装系统已经完成，如果有显示的同学可直接进入树莓派系统" class="headerlink" title="此时树莓派的安装系统已经完成，如果有显示的同学可直接进入树莓派系统"></a>此时树莓派的安装系统已经完成，如果有显示的同学可直接进入树莓派系统</h4><hr>
<blockquote>
<p>以下内容针对没有显示屏的同学</p>
</blockquote>
<h3 id="2-我们来远程登录树莓派"><a href="#2-我们来远程登录树莓派" class="headerlink" title="2.我们来远程登录树莓派"></a>2.我们来远程登录树莓派</h3><h4 id="2-1准备工作"><a href="#2-1准备工作" class="headerlink" title="2.1准备工作"></a>2.1准备工作</h4><p>我们将SD卡再插入电脑，打开SD卡盘符新建ssh文件（因为自2016年9月开始，raspberry默认关闭ssh连接）</p>
<blockquote>
<p><strong>注</strong>：这里是文件，而不是文本文件，删除其后缀的办法是打开<strong>控制面板</strong> \ <strong>文件资源管理器选项</strong> \ <strong>查看</strong>，取消勾选隐藏已知文件类型的拓展名，点确定，如图然后再将ssh后边新多出的<code>.txt</code>删除 <div  align="center"><img src="https://raw.githubusercontent.com/Asmikezheng/photo/raspberry/text.png" style="zoom:50%"></div></p>
</blockquote>
<h4 id="2-2正式开始"><a href="#2-2正式开始" class="headerlink" title="2.2正式开始"></a>2.2正式开始</h4><ul>
<li>首先将树莓派通过网线连接至路由器</li>
<li>在笔记本电脑中打开：控制面板 \ 网络和共享中心 \ 更改适配器设置，找到无线网络连接右键“属性”，在共享选项卡上选中“允许其他网络用户通过此计算机的Internet连接来连接（N）”选项,如图，点确定。</li>
</ul>
<div  align="center"><img src="https://raw.githubusercontent.com/Asmikezheng/photo/raspberry/win10int.png" style="zoom:50%"></div>

<ul>
<li>而后进入路由器的管理员界面，我用的是TP-Link，所以其管理员网址为<a href="http://tplogin.cn/" target="_blank" rel="noopener">http://tplogin.cn/</a> 登录后在设备管理界面找到树莓派，如图，查看其IP，我的树莓派IP是192.168.1.100</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Asmikezheng/photo/raspberry/raspberryip1.png" alt="raspberry1"><br><img src="https://raw.githubusercontent.com/Asmikezheng/photo/raspberry/raspberryip2.png" alt="raspberry2"></p>
<ul>
<li>使用Putty或者Xshell远程登录，在IP处输入已获取的树莓派的IP，选择22号端口，单击open即可进入Raspbian的命令行界面。</li>
</ul>
<blockquote>
<p>初始用户名：pi<br>初始密码：raspberry</p>
</blockquote>
<h3 id="3-VNC远程桌面"><a href="#3-VNC远程桌面" class="headerlink" title="3.VNC远程桌面"></a>3.VNC远程桌面</h3><p>首先在电脑上安装VNC viewer<a href="https://www.realvnc.com/en/connect/download/viewer/" target="_blank" rel="noopener">这里</a>。而后启动PC端的VNC Viewer输入树莓派的IP和链接密码即可进入树莓派的操作界面。如图：</p>
<p><img src="https://raw.githubusercontent.com/Asmikezheng/photo/raspberry/end.png" alt="end"></p>
<h3 id="散花"><a href="#散花" class="headerlink" title="散花"></a>散花</h3>]]></content>
      <categories>
        <category>Raspberry</category>
      </categories>
  </entry>
  <entry>
    <title>hexo-github个人博客搭建</title>
    <url>/2020/03/13/hexofirst/</url>
    <content><![CDATA[<h1 id="hexo-github个人博客搭建"><a href="#hexo-github个人博客搭建" class="headerlink" title="hexo-github个人博客搭建"></a>hexo-github个人博客搭建</h1><blockquote>
<p>作为经过两天搭建和调试之后的总结，希望可以帮助到更多的人，同时也作为本站第一篇博客，小激动max<br><a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>github</strong>是一款面向开源和私有（曾经是收费的现在已经可以免费使用）软件软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub。</p>
</blockquote>
<p><strong>hexo</strong>是一款简洁，高效（只有三行代码就可以把博客部署到远端）的博客框架，并且有很多插件可以使用。</p>
<p><strong>优缺点</strong>关于github的登录和浏览有的时候可能因为万里长城的原因而有些慢，但是托管在github上移动方便，还省心。</p>
<p><strong>准备工作</strong>：</p>
<blockquote>
<p><strong>注</strong>：本文是在win10系统下进行操作</p>
</blockquote>
<ul>
<li><strong>首先要注册一个github账号</strong></li>
<li><strong>下载node.js</strong><a href="https://nodejs.org" target="_blank" rel="noopener">这里</a>，<strong>进入界面后点击第一个大的绿色框框，是指的node的长期支持版，下载好之后安装在任意位置</strong></li>
<li><strong>下载git</strong><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">这里</a>，</li>
</ul>
<blockquote>
<p><strong>那让我们开始吧</strong></p>
</blockquote>
<h3 id="1-进入命令管理器"><a href="#1-进入命令管理器" class="headerlink" title="1. 进入命令管理器"></a>1. 进入命令管理器</h3><h4 id="win-R后在弹窗中输入cmd"><a href="#win-R后在弹窗中输入cmd" class="headerlink" title="win+R后在弹窗中输入cmd"></a>win+R后在弹窗中输入cmd</h4><p>输入<code>node -v</code>可以查看到之前安装的node版本信息，证明安装成功，如图我的版本是10.16.0：<br><img src="https://raw.githubusercontent.com/Asmikezheng/photo/hexo/node.png" alt="node"></p>
<p>接下来在cmd中继续输入<br><code>npm install -g cnpm --registry=http://registry.npm.taobao.org</code> 这里为什么是淘宝的呢？因为国内的直接下载比较慢，用淘宝的镜像相对来说会快一些。然后输入<code>cnpm -v</code>会弹出其版本号，证明安装成功。</p>
<blockquote>
<p><strong>注</strong>：这里可能会比较慢，甚至安装不成功，这是因为丢包等原因，所以可以多试几次</p>
</blockquote>
<p>继续输入<code>cnpm install -g hexo-cli</code>安装hexo，等待完成后同样输入<code>hexo -v</code>可以看到其版本号如图：<br><img src="https://raw.githubusercontent.com/Asmikezheng/photo/hexo/hexo.png" alt="hexo"></p>
<h3 id="2-在你喜欢的目录下搭建博客"><a href="#2-在你喜欢的目录下搭建博客" class="headerlink" title="2.在你喜欢的目录下搭建博客"></a>2.在你喜欢的目录下搭建博客</h3><h4 id="2-1创建文件夹"><a href="#2-1创建文件夹" class="headerlink" title="2.1创建文件夹"></a>2.1创建文件夹</h4><ul>
<li><p><strong>通过鼠标右键创建新文件夹命名为喜欢的名字，我就命名为blog好了</strong><br>这时候接下来的大部分操作都是对这个文件夹里即将出现的文件进行操作，之后出现的问题，解决无果可以直接把这个文件夹删掉重新来过。</p>
</li>
<li><p><strong>通过cmd界面进入这个文件夹</strong><br><code>cd blog</code>就可以进入目录。输入<code>hexo init</code>之后等待一段时间，就会发现blog文件夹中多出了很多文件，这些就是hexo自动为你搭建起来的基础博客框架。</p>
</li>
</ul>
<blockquote>
<p><strong>注</strong>这里如果没有反应的话可以点进blog文件夹，右键后选择Git Bash here，而后输入<code>hexo init</code>也可以实现目标</p>
</blockquote>
<p><strong>这样博客的基础框架就已经在本地搭建完成啦。这时候接着输入<code>hexo start</code>可以启动本地预览功能如图：(不要理会中间那好几行黄字的WARN，重点在最后一行)</strong></p>
<p><img src="https://raw.githubusercontent.com/Asmikezheng/photo/hexo/hexostart.png" alt="hexostart"></p>
<h4 id="这时候打开浏览器输入最后一行的网址http-localhost-4000，就可以本地预览搭建好的博客啦。"><a href="#这时候打开浏览器输入最后一行的网址http-localhost-4000，就可以本地预览搭建好的博客啦。" class="headerlink" title="这时候打开浏览器输入最后一行的网址http://localhost:4000，就可以本地预览搭建好的博客啦。"></a><strong>这时候打开浏览器输入最后一行的网址<a href="http://localhost:4000，就可以本地预览搭建好的博客啦。">http://localhost:4000，就可以本地预览搭建好的博客啦。</a></strong></h4><blockquote>
<p>最后按Ctrl+c，然后按y，然后回车就可以结束进程</p>
</blockquote>
<h4 id="2-2写自己的第一篇博客"><a href="#2-2写自己的第一篇博客" class="headerlink" title="2.2写自己的第一篇博客"></a>2.2写自己的第一篇博客</h4><ul>
<li><p>可以在网上搜索各种支持markdown的编辑器，比如我使用的是<a href="https://maxiang.io/" target="_blank" rel="noopener">马克飞象</a>，按照markdown语法写下，直接复制到<code>blog\source\_posts</code>目录下的一个文本编辑器中。</p>
</li>
<li><p>其中有一篇hexo自动生成的<code>helloword</code>文件，也就是刚刚打开<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 看到的那篇。</p>
</li>
<li><p>然后再命令行中输入<code>hexo g</code>使得hexo生成静态网页，然后输入<code>hexo s</code>就又回到上一张图片处，但是不同的是在博客中出现了一篇<strong>新的博文</strong>。</p>
</li>
</ul>
<p><strong>是不是很惊喜，就是这么的简单</strong></p>
<blockquote>
<p><strong>注1</strong>：<strong>本地预览</strong>是为了先看到博文的样子，对于错误进行自查和修改<br><strong>注2</strong>：结束的方式是<code>ctrl+c</code>然后再按Y键</p>
</blockquote>
<h3 id="3-将本地的hexo和github联系起来"><a href="#3-将本地的hexo和github联系起来" class="headerlink" title="3.将本地的hexo和github联系起来"></a>3.将本地的hexo和github联系起来</h3><h4 id="3-1登录github与新建仓库"><a href="#3-1登录github与新建仓库" class="headerlink" title="3.1登录github与新建仓库"></a>3.1登录github与新建仓库</h4><p>登录github后点击Repositories，位置如图，建立一个新的仓库（右边有一个绿色的new的按钮就是新建仓库）：<br><img src="https://raw.githubusercontent.com/Asmikezheng/photo/hexo/block.png" alt=""></p>
<blockquote>
<p><strong>注</strong>这里一定要注意用户部署个人博客的github仓库的命名必须符合特定要求才行，必须是<code>用户名.github.io</code></p>
</blockquote>
<p>下边都默认就好</p>
<p>然后回到命令行中输入<code>cnpm install --save hexo-deployer-git</code>安装一个git的部署的插件</p>
<h4 id="3-2设置关联"><a href="#3-2设置关联" class="headerlink" title="3.2设置关联"></a>3.2设置关联</h4><p>用文本编辑器打开blog文件夹里的<code>_config.yml</code>文件拉到最后输入<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@requires_authorization</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  type: <span class="string">'git'</span></span><br><span class="line">  repo: https://github.com/user/user.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注</strong>：其中第五行git必须在引号之<strong>内</strong>，并且冒号之后有一个<strong>空格</strong></p>
</blockquote>
<h4 id="3-3-将本地博客推向远端"><a href="#3-3-将本地博客推向远端" class="headerlink" title="3.3 将本地博客推向远端"></a>3.3 将本地博客推向远端</h4><p>在命令行中输入<code>hexo d</code>在下边的提示中输入github的账号和密码，等待一下</p>
<blockquote>
<p><strong>注1</strong>：这里要是报错（git没有global身份）的话回到Git界面输入<code>git config --global user.name</code>再输入<code>git config --global user.email</code>“xxx@xxx”<br><strong>注2</strong>：同时推向远端不一定马上就能看到更新之后的样子，因为不要着急多刷新几次就好了</p>
</blockquote>
<p>然后在github之前新建的仓库中就能看到一些文件啦，其实就是blog文件夹中的文件上传到github上</p>
<p><strong>这时候输入<a href="http://user.github.io" target="_blank" rel="noopener">http://user.github.io</a> 就可以进入远端的博客啦</strong></p>
<h3 id="以上就是搭建一个hexo-github博客的全部啦，散花"><a href="#以上就是搭建一个hexo-github博客的全部啦，散花" class="headerlink" title="以上就是搭建一个hexo-github博客的全部啦，散花"></a><strong>以上就是搭建一个hexo-github博客的全部啦，散花</strong></h3>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>纪念丹尼斯.里奇--一切源于hello World</title>
    <url>/2020/03/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
      <categories>
        <category>使用说明</category>
      </categories>
  </entry>
</search>
